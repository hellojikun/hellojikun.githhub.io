<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="SocketServer模块 建立Socket，保持和客户端的通信 准发客户端的Request 返回Response给客户端 通过RequestChannel与其他模块解耦  KafkaRequestHandlerPoolkafkaRequestHandlerPool本质上市一个线程池，默认包含8个IO处理线程 kafkaRequestHandlerkafkaRequestHandler需要从Re">
<meta property="og:type" content="article">
<meta property="og:title" content="kafka：Broker基础模块">
<meta property="og:url" content="http://yoursite.com/2019/12/25/kafka%EF%BC%9ABroker%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="SocketServer模块 建立Socket，保持和客户端的通信 准发客户端的Request 返回Response给客户端 通过RequestChannel与其他模块解耦  KafkaRequestHandlerPoolkafkaRequestHandlerPool本质上市一个线程池，默认包含8个IO处理线程 kafkaRequestHandlerkafkaRequestHandler需要从Re">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://assets.processon.com/chart_image/5cc119eae4b085d01084919e.png">
<meta property="og:image" content="http://assets.processon.com/chart_image/5c3f28c1e4b0f430ae0552c7.png">
<meta property="og:image" content="http://assets.processon.com/chart_image/5d4ab0f0e4b0423002bd8057.png">
<meta property="article:published_time" content="2019-12-25T13:20:27.000Z">
<meta property="article:modified_time" content="2019-12-25T13:21:21.077Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="kafka">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://assets.processon.com/chart_image/5cc119eae4b085d01084919e.png">

<link rel="canonical" href="http://yoursite.com/2019/12/25/kafka%EF%BC%9ABroker%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>kafka：Broker基础模块 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/kafka%EF%BC%9ABroker%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          kafka：Broker基础模块
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-12-25 21:20:27 / Modified: 21:21:21" itemprop="dateCreated datePublished" datetime="2019-12-25T21:20:27+08:00">2019-12-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="SocketServer模块"><a href="#SocketServer模块" class="headerlink" title="SocketServer模块"></a>SocketServer模块</h2><ul>
<li>建立Socket，保持和客户端的通信</li>
<li>准发客户端的Request</li>
<li>返回Response给客户端</li>
<li>通过RequestChannel与其他模块解耦</li>
</ul>
<h3 id="KafkaRequestHandlerPool"><a href="#KafkaRequestHandlerPool" class="headerlink" title="KafkaRequestHandlerPool"></a>KafkaRequestHandlerPool</h3><p>kafkaRequestHandlerPool本质上市一个线程池，默认包含8个IO处理线程</p>
<h3 id="kafkaRequestHandler"><a href="#kafkaRequestHandler" class="headerlink" title="kafkaRequestHandler"></a>kafkaRequestHandler</h3><p>kafkaRequestHandler需要从RequestChannel的RequestQueue中取出Request，并利用KafkaApis处理具体的业务逻辑<br>主要逻辑步骤：</p>
<ul>
<li>从requestChannel的request阻塞队列获取请求，如果请求不到，则在whil循环中不断重试</li>
<li>判断请求类型 如果是ShutDownRequest 则退出，如果是Request类型，则调用 apis完成请求<h3 id="kafkaApis"><a href="#kafkaApis" class="headerlink" title="kafkaApis"></a>kafkaApis</h3>kafkaApis主要负责具体的业务逻辑，它主要和producer，consumer，brokerServer交互，Kafka主要依赖四个组件完成具体的业务逻辑：</li>
<li>LogManager提供kafka的Topic日志的读取和写入功能。</li>
<li>ReplicaManager提供对Topic的分区副本数据的同不功能。</li>
<li>OffsetManager提供对提交至kafka的偏移量的管理功能</li>
<li>kafkaScheduler为分析其他模块提供定时的调度和管理功能。</li>
</ul>
<h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><h4 id="Message物理格式"><a href="#Message物理格式" class="headerlink" title="Message物理格式"></a>Message物理格式</h4><table>
<thead>
<tr>
<th>关键字</th>
<th>大小(byte)</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>offset</td>
<td>8</td>
<td>在partition内的offset</td>
</tr>
<tr>
<td>message size</td>
<td>4</td>
<td>message 大小</td>
</tr>
<tr>
<td>CRC32</td>
<td>4</td>
<td>CRC32校验码</td>
</tr>
<tr>
<td>magic</td>
<td>1</td>
<td>kafka服务程序协议版本号</td>
</tr>
<tr>
<td>attributes</td>
<td>1</td>
<td>表示独立版本，或压缩类型，编码类型</td>
</tr>
<tr>
<td>key length</td>
<td>4</td>
<td>key长度</td>
</tr>
<tr>
<td>key</td>
<td>k</td>
<td>可选</td>
</tr>
<tr>
<td>value</td>
<td>k</td>
<td>表示实际消息</td>
</tr>
</tbody></table>
<h3 id="kafka读写message特点"><a href="#kafka读写message特点" class="headerlink" title="kafka读写message特点"></a>kafka读写message特点</h3><h4 id="写message"><a href="#写message" class="headerlink" title="写message"></a>写message</h4><h4 id="logManager"><a href="#logManager" class="headerlink" title="logManager"></a>logManager</h4><p>loggerManager负责提供BrokerServer上的topic的分区数据的读取和写入功能，负责读取数据和写入位于BrokerServer上的所有分区副本数据；如果partition有多个Replica，则每个BrokerServer不会存在相同的Partition的多份副本，失去了一定的可靠性。<br>LoggerMannager利用logs来管理BrokerServer内部的日志，通过TopicAndPartition来索引不同的Topic的不同的Partition数据。<br>Log利用segments来管理partition的数据，里面包含了多个日志段，即LogSegment<br>LogManager，Log，LogSegment的关系如下所示</p>
<p><img src="http://assets.processon.com/chart_image/5cc119eae4b085d01084919e.png" alt="image"></p>
<h5 id="logSegment"><a href="#logSegment" class="headerlink" title="logSegment"></a>logSegment</h5><p>logSegment中的log代表了消息集合，每条消息都有一个ofset，index代表消息的索引信息，以kv的形式记录，其中k为消息在log中的相对偏移量，v为消息在log中的绝对位置，baseOffset代表的是该LogSegment日志段的起始偏移量，indexIntervalBytes代表的是索引的粒度，即写入多少字节后生成一条索引，OffsetIndex不会保存每条消息的索引，因此其索引文件是一个稀疏索引文件。<br><img src="http://assets.processon.com/chart_image/5c3f28c1e4b0f430ae0552c7.png" alt="image"></p>
<h3 id="kafka的消息读取"><a href="#kafka的消息读取" class="headerlink" title="kafka的消息读取"></a>kafka的消息读取</h3><p> BrokerServer定位具体的消息：</p>
<ul>
<li><p>步骤一：根据startOffset定位位于哪一个Logsegment，其中segments的数据结构为ConcurrentSkipListMap，是一种跳表结构。<br>跳跃表分为与多层，每一层都可以看作是数据的索引，这些索引的意义就是加快跳跃表的查询速度，每一层的数据都是有序的，上一层的数据是下一层的数据的的子集，并且第一层包含了全部的数据，层次越高，跳跃性越大，包含的数据越少，跳跃表包含了一哥表头，查找数据是从上往下，从左往右进行，需要找出小于等于starOffset的节点</p>
<ul>
<li><p>步骤二：当找到具体的logSegment的时候，则调用read方法，关键是如何定位到日志段文件的起始物理就偏移量，</p>
<ul>
<li><p>阶段一：通过二分查找找到小于等于startOffset的最近索引记录位置</p>
</li>
<li><p>阶段二：打开log文件，将文件指针移动偏移量为497的位置，然后从这个位置往下读数据。<br>log数据文件的消息格式 8个字节的消息偏移量+4个字节的消息长度+消息内容</p>
<p> 最后利用OffsetPosition返回的物理位置信息读取指定的偏移量开始的信息</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="logManager的启动"><a href="#logManager的启动" class="headerlink" title="logManager的启动"></a>logManager的启动</h4><p> LogManager在启动过程中主要做了两件事，1.初始化logs；2.开启后台定时任务和维护线程。</p>
<h3 id="ReplicaManager"><a href="#ReplicaManager" class="headerlink" title="ReplicaManager"></a>ReplicaManager</h3><p>ReplicaMannager 负责提供对Topic分区副本数据的同步功能，需要对不同变化及时做出响应。例如Partition的Replicas发生leader切换时候。 </p>
<ol>
<li><p>AR是Assign Replicas的缩写，代表已经分配给partition的副本</p>
</li>
<li><p>ISR 是In-Syn Replicas的缩写，代表正在处于同步状态的副本。</p>
</li>
<li><p>ReplicaManager如何实现replica数据同步? 主要利用 ReolicaFetcherRhread（副本数据拉取线程）和High Watermark Mechanism(高水位线机制)来实现数据的同步管理<br><img src="http://assets.processon.com/chart_image/5d4ab0f0e4b0423002bd8057.png" alt="image"></p>
</li>
<li><p>Replica的HighWatermark何时更新。<a href="https://www.cnblogs.com/huxi2b/p/7453543.html" target="_blank" rel="noopener">https://www.cnblogs.com/huxi2b/p/7453543.html</a> </p>
</li>
</ol>
<ol start="5">
<li>LEO更新机制<br>kafka设计了两套follower副本的LEO属性，一套LEO保存在follower自身所在的broker缓存上，另一套存在leader副本所在机器上， 也就是说leader副本所在机器的缓存上保存了该分区所有的follower副本的LEO属性<ol>
<li>follower副本端更新followerLEO</li>
<li>leader副本端的follower副本LEO跟新</li>
</ol>
</li>
<li>leader更新分区HW <ol>
<li>副本成为leader</li>
<li>broker出现崩溃导致副本被提出ISR时</li>
<li>producer向leader副本写入消息时，写入消息leader会更新自己的LEO，有必要查看HW是否更新。</li>
<li>leader处理follower Fetch请求时，leader处理follower的FETCH请求时，会从底层log读取数据，之后再尝试更新HW</li>
</ol>
</li>
</ol>
<h3 id="OffsetManager"><a href="#OffsetManager" class="headerlink" title="OffsetManager"></a>OffsetManager</h3><p>Kadfka提供了两种保存Consumer偏移量的方法:</p>
<ul>
<li>1.将偏移量保存在Zookeeper当中</li>
<li>2.将偏移量保存到kafka内部一个名为__consumer_offsts的topic当中，将偏移量保存写入zookeeper中的kafka就一直支持的，但是zookeeper并不适合大批量频繁的执行写入操作，因此kafka将开始支持将consumeer的偏移量保存到kafka的内部topic当中。<br> OffsetManager主要提供一下几个功能：</li>
<li>缓存最新的偏移量</li>
<li>提供对偏移量的查询</li>
<li>COmpact，保留最新的偏移量，以此来控制Topic的日志大小<br>offsetsCache提供对Consumer偏移量的保存和查询，compact作为定时任务，间隔config.ofsetRetentionCheckIntervalMs执行</li>
</ul>
<h4 id="Consumer偏移量的保存"><a href="#Consumer偏移量的保存" class="headerlink" title="Consumer偏移量的保存"></a>Consumer偏移量的保存</h4><p>Consumer将偏移量保存在kafka，类似于生产者将消息发布到kafka集群的topic，将偏移量包装成消息发送到__consumer_offsets,当brokerServer接收消息时，除了将消息保存到日志外，还会调用OffsetManager提供的putOffsets方法将消息保存到offsetsCache中</p>
<h4 id="consumer偏移量的读取"><a href="#consumer偏移量的读取" class="headerlink" title="consumer偏移量的读取"></a>consumer偏移量的读取</h4><p>当BrokerServer接收到查询偏移量的请求时，如果发现偏移量保存在kafka中，则调用OffsetManager提供getOffsets方法将偏移量取出<br>kafka通过计算不同Consumer group的hash值和__consumer_offsets的分区数法人模数，其结果作为制定分区的索引。</p>
<h4 id="compact-策略"><a href="#compact-策略" class="headerlink" title="compact 策略"></a>compact 策略</h4><p>当Consumer group经过长时间运行之后，不再产生消息偏移量，很可能其已经不需要保存在__consumer_offsetsl里面的就偏移量信息，这就是compact策略。这个策略将会长时间没有更新的consumer group对应的偏移量清理掉，保留持续不断在更新的consumer group的偏移量。</p>
<h4 id="kafkaScheduler"><a href="#kafkaScheduler" class="headerlink" title="kafkaScheduler"></a>kafkaScheduler</h4><p>kafkaScheduler为其他模块提供定时任务调度和管理，kafkaScheduler内部是基于ScheduledThreadPoolExecutor实现的，对外封装了任务调度的接口schedule，线程个数由参数background.threads决定，默认为10，</p>
<h4 id="KafkaApis模块"><a href="#KafkaApis模块" class="headerlink" title="KafkaApis模块"></a>KafkaApis模块</h4><p>KafkaApis模块主要负责不同业务请求的具体实现逻辑。需要利用以下四个模块相互配合来完成操作。LogManager，ReplicaManager，OffsetManager，KafkaScheduler。<br>KafkaAPis负责的请求类型包含以下十一类：</p>
<ul>
<li>ProducerRequest 生产者发送消息的请求</li>
<li>FetchRequest 消费者获取消息的请求</li>
<li>OffsetRequest 获取Topic当前的offset的元数据信息请求</li>
<li>TopicMetadataRequest 获取Topic元数据信息的请求</li>
<li>LeaderAndIsrRequest，Topic元数据信息发生变化的请求</li>
<li>StopReplicaRequest， 停止拷贝副本数据的请求</li>
<li>UpdateMetadataRequest 更新Topic元数据信息的请求</li>
<li>BrokerControlledShutDownRequest broker server下线请求</li>
<li>OffsetCommitRequest 消费者保存偏移量的请求</li>
<li>OffsetFetchRequest 获取消费者获取消费详情的请求</li>
<li>ConsumerMetadataRequest 高级消费者获取Consumer Group 分区信息的请求<br>kafka集群客户端和Broker Server，Broker Server和Broker Server 之间交互的二进制数据格式为请求类型+请求的数据<h4 id="ProducerRequest"><a href="#ProducerRequest" class="headerlink" title="ProducerRequest"></a>ProducerRequest</h4>当生产者发送消息保存至kafka集群时或者高级消费者发送偏移量保存至kafka集群时，都会发送此种类型的请求。对于后者可以将其看成一种特殊的消息。消息里面内容是特定topic的偏移量，当broker server收到此种类型的消息时。主要完成以下两件事情</li>
<li>1.持久化消息</li>
<li>2.组装响应格式 除此之外如果是高级消费者发送的偏移量请求时，则会将该偏移量同时保存到内存中<br>请求的二进制数据格式如图：</li>
</ul>
<p>ProducerRequest.requiredAcks的取值是由request.required.acks决定的，在返回响应的时候主要针对其的不同取值进行不同处理。<br>当值为-1时，此时不会立刻返回broker端消息持久化得结果。需要等待partition的isr列表中的replica完成数据同步，切isr列表的个数大于min.insync.replicas 时才会将响应返回给对应的客户端<br>当acks = -1时，kafka是如何做到延迟答复。他采用一种称为purgator的策略。</p>
<h4 id="FetchRequest"><a href="#FetchRequest" class="headerlink" title="FetchRequest"></a>FetchRequest</h4><p>当状态为Follower的Replica向状态为Leader的Replica同步数据的时，或者消费者获取数据时，Replica会发送FetchRequest类型的请求。broker接收到此类请求后，除了将需要的数据返回之外，还会根据不同的情况更新一些元数据信息</p>
<ul>
<li>如果是来自状态为Folower的replica请求，如何更新元数据信息<ul>
<li>更新对应Replica的LEO</li>
<li>更新Leader Replica的highWatermark</li>
<li>可能需要扩大的ISR列表，是因为发生了数据同步，导致可能有更多的Replica已经和状态为Leader的Replica保持了同步。更新完数据之后，就去检查该Broker Server上的DelayedProducer是否满足条件返回响应。因为发生了数据同步之后，导致之前的DelayedProduceRequest得到了更多的Replica的确认。</li>
</ul>
</li>
<li>DelayedFetchRequest如何判断满足条件的<ul>
<li>在kafka集群正常运行过程中。fetchOffset和endOffset都位于当期的segment上，因此主要统计哪些可以fetch的数量是否满足最小的数据量的要求，只要满足，就可以响应DelayedFetchRequest</li>
</ul>
</li>
</ul>
<h4 id="OffsetRequest"><a href="#OffsetRequest" class="headerlink" title="OffsetRequest"></a>OffsetRequest</h4><p>当消费者或者是客户端想要获取topic某个时间段内的偏移量详情时会发送此类型的请求。broker接收到此请求的时候，会返回指定修改时间之前的LogSegment的baseOffset</p>
<h4 id="TopicMetadataRequest"><a href="#TopicMetadataRequest" class="headerlink" title="TopicMetadataRequest"></a>TopicMetadataRequest</h4><p>当生产者或者消费者想要获取Topic的元数据会发送此类请求</p>
<h4 id="LeaderAndIsrRequest"><a href="#LeaderAndIsrRequest" class="headerlink" title="LeaderAndIsrRequest"></a>LeaderAndIsrRequest</h4><p>&ensp;&ensp; 如果某Broker Server由于异常导致宕机，则原先Leader Replica在该broker上的topic会发生Replica的leader切换，以及In—Sync Replica列表的缩减。如果由于网络延迟，导致原先位于In-Sync Replicas列表的Replica没有长时间向LeaderReplica同步数据，最后导致落后太多的数据，此时需要将该Replica从ISR列表中删除。如果用户手动重新指定Topic的分布情况。则可能发生topic的Replica Leader切换，以及ISR列表的变化等.<br>&ensp;&ensp;当发生以上几种情况的时候，Leader状态的kafkaController所在的Broker Server会向相关的 broker server<br>下发topic的leader或者isr列表发生变化的请求，broker接收到此请求后会根据具体的内容对变化的replica进行相应的处理<br>&ensp;&ensp;当leader和isr发生变化的时候分为两种情况：</p>
<ul>
<li>当某个replica称为leader  <ol>
<li>暂停fetch线程</li>
<li>添加进Assigned Replica列表</li>
<li>添加进In-Sync Replica列表</li>
<li>删除已经不存在的Assigned Replica</li>
<li>初始化LeaderReplica 的High Watchermark</li>
</ol>
</li>
<li>当某个replica称为follwer<ol>
<li>暂停旧的fetch线程</li>
<li>截断数据到HighWatchermark</li>
<li>开启新的Fetch线程</li>
<li>添加进Assign Replica列表</li>
<li>删除已经不存在的Assigned Replica<h4 id="StopReplicaREquest"><a href="#StopReplicaREquest" class="headerlink" title="StopReplicaREquest"></a>StopReplicaREquest</h4></li>
</ol>
</li>
</ul>
<p>&ensp;&ensp;当topic的某个分区被删除或者强制下线的时候，处于Leader状态的KafakController会发送此请求到相关的broker server。<br>StopReplica请求中的deletePartitionsca</p>
<h4 id="UpdateMetadataRequest"><a href="#UpdateMetadataRequest" class="headerlink" title="UpdateMetadataRequest"></a>UpdateMetadataRequest</h4><p>&ensp;&ensp;当topic的元数据发生改变时，例如 TopicAndPartition 的leader Replica，In-SyncReplicas,Assigned Replicas等等,处于Leader状态下的kafakController会发送次请求到相关的broker。</p>
<h4 id="读取offset"><a href="#读取offset" class="headerlink" title="读取offset"></a>读取offset</h4><ol>
<li>版本为0 ，在zk上拉取数据，负责查询kafka</li>
<li>要确保topic在broker上存在</li>
<li>从zk读取数据，如果有数据则返回数据，否则返回错误吗</li>
<li>版本不为0 ，则从broker内存中读取</li>
<li>分组筛选存在和不存在的topic</li>
<li>存在的返回结果，不存在的返回错误码<h4 id="kafka健康状态"><a href="#kafka健康状态" class="headerlink" title="kafka健康状态"></a>kafka健康状态</h4>BrokerChangeListener监听器监听目录为/brokers/ids的zk路径，当发生数据变化时候。则获取当前目录下的的数据，从而获取当前集群的broker server.KafakHealthcheck提供了在目录brokers/ids的zk路径注册节点能力。该节点为EphemeralPath(非永久路径)。当brokers server由于异常下线时，此路径由于链接断开而消失</li>
</ol>
<h4 id="topic配置在线修改"><a href="#topic配置在线修改" class="headerlink" title="topic配置在线修改"></a>topic配置在线修改</h4><p>kafka提供了对topic配置的在线修改能力，修改完成无需重启kafka集群在线生效。<br>Topic的配置参数位于zk上，路径为/config/topics/[topic],brokers/changes目录记录更新变化</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> kafkaApis处理具体业务逻辑，利用LogManage，Replicamanage，OffsetManage，KafkaHealthcheck，四大模块完成具体业务，Broker对外暴露了11条通信协议</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/kafka/" rel="tag"># kafka</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/25/kafka/" rel="prev" title="kafka">
      <i class="fa fa-chevron-left"></i> kafka
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#SocketServer模块"><span class="nav-number">1.</span> <span class="nav-text">SocketServer模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KafkaRequestHandlerPool"><span class="nav-number">1.1.</span> <span class="nav-text">KafkaRequestHandlerPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafkaRequestHandler"><span class="nav-number">1.2.</span> <span class="nav-text">kafkaRequestHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafkaApis"><span class="nav-number">1.3.</span> <span class="nav-text">kafkaApis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Message"><span class="nav-number">1.4.</span> <span class="nav-text">Message</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Message物理格式"><span class="nav-number">1.4.1.</span> <span class="nav-text">Message物理格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka读写message特点"><span class="nav-number">1.5.</span> <span class="nav-text">kafka读写message特点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#写message"><span class="nav-number">1.5.1.</span> <span class="nav-text">写message</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#logManager"><span class="nav-number">1.5.2.</span> <span class="nav-text">logManager</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#logSegment"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">logSegment</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka的消息读取"><span class="nav-number">1.6.</span> <span class="nav-text">kafka的消息读取</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#logManager的启动"><span class="nav-number">1.6.1.</span> <span class="nav-text">logManager的启动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReplicaManager"><span class="nav-number">1.7.</span> <span class="nav-text">ReplicaManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OffsetManager"><span class="nav-number">1.8.</span> <span class="nav-text">OffsetManager</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Consumer偏移量的保存"><span class="nav-number">1.8.1.</span> <span class="nav-text">Consumer偏移量的保存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#consumer偏移量的读取"><span class="nav-number">1.8.2.</span> <span class="nav-text">consumer偏移量的读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#compact-策略"><span class="nav-number">1.8.3.</span> <span class="nav-text">compact 策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kafkaScheduler"><span class="nav-number">1.8.4.</span> <span class="nav-text">kafkaScheduler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KafkaApis模块"><span class="nav-number">1.8.5.</span> <span class="nav-text">KafkaApis模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ProducerRequest"><span class="nav-number">1.8.6.</span> <span class="nav-text">ProducerRequest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FetchRequest"><span class="nav-number">1.8.7.</span> <span class="nav-text">FetchRequest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OffsetRequest"><span class="nav-number">1.8.8.</span> <span class="nav-text">OffsetRequest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TopicMetadataRequest"><span class="nav-number">1.8.9.</span> <span class="nav-text">TopicMetadataRequest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LeaderAndIsrRequest"><span class="nav-number">1.8.10.</span> <span class="nav-text">LeaderAndIsrRequest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StopReplicaREquest"><span class="nav-number">1.8.11.</span> <span class="nav-text">StopReplicaREquest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UpdateMetadataRequest"><span class="nav-number">1.8.12.</span> <span class="nav-text">UpdateMetadataRequest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读取offset"><span class="nav-number">1.8.13.</span> <span class="nav-text">读取offset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kafka健康状态"><span class="nav-number">1.8.14.</span> <span class="nav-text">kafka健康状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#topic配置在线修改"><span class="nav-number">1.8.15.</span> <span class="nav-text">topic配置在线修改</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">1.9.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
